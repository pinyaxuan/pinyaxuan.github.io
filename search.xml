<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【科赛-练习赛】：文本情感分类模型搭建</title>
      <link href="/2019/03/15/kesci-sentiment-classification/"/>
      <url>/2019/03/15/kesci-sentiment-classification/</url>
      
        <content type="html"><![CDATA[<p>记录参加科赛举办的文本情感分类模型-练习赛，比赛地址： <a href="https://www.kesci.com/home/competition/5c77ab9c1ce0af002b55af86">文本情感分类模型搭建 | 练习赛</a><br>使用TFIDF提前词频特征，利用PyTorch搭建线性预测模型，预测结果AUC 0.8658，截止2019-3-14科赛网公网排名第三。</p><p><img src="/./kesci-sentiment-classification/kesci-sentiment-classification-intro.png" alt="科赛排名（2019-3-14）"></p><h2 id="赛题描述"><a href="#赛题描述" class="headerlink" title="赛题描述"></a>赛题描述</h2><p>本练习赛所用数据，是名为「Roman Urdu DataSet」的公开数据集。</p><p>这些数据，均为文本数据。原始数据的文本，对应三类情感标签：Positive, Negative, Netural。</p><p>本练习赛，移除了标签为Netural的数据样例。因此，练习赛中，所有数据样例的标签为Positive和Negative。</p><p>本练习赛的任务是「分类」。「分类目标」是用训练好的模型，对测试集中的文本情感进行预测，判断其情感为「Negative」或者「Positive」。</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><a href="https://github.com/jianchengss/kesci-sentiment-classification.git">https://github.com/jianchengss/kesci-sentiment-classification.git</a></p><h2 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h2><p><img src="/./kesci-sentiment-classification/kesci-sentiment-classification-3.png" alt="科赛排名（2019-3-14）"></p><p>实验结果摘要：</p><table><thead><tr><th>Date</th><th>SHA</th><th>Method</th><th>AUC-train</th><th>AUC-kesci</th><th>P</th><th>R</th><th>F</th></tr></thead><tbody><tr><td>20190307</td><td>8225844</td><td>random</td><td>-</td><td>0.5057</td><td>-</td><td>-</td><td>-</td></tr><tr><td>20190312</td><td>05a6790</td><td>rfc-1</td><td>0.8130</td><td>0.8054</td><td>0.7516</td><td>0.7542</td><td>0.7520</td></tr><tr><td>20190312</td><td>d4e00a1</td><td>neural_clf</td><td>0.8336</td><td>0.8357</td><td>0.7831</td><td>0.7638</td><td>0.7728</td></tr><tr><td>20190313</td><td>9dae25e</td><td>forest-2</td><td>0.8269</td><td>0.8229</td><td>0.7602</td><td>0.7726</td><td>0.7656</td></tr><tr><td>20190313</td><td>78f2dc7</td><td>neural_clf</td><td>0.8352</td><td>0.8412</td><td>0.7723</td><td>0.7806</td><td>0.7762</td></tr><tr><td>20190313</td><td>14075a4</td><td>soft_max</td><td>0.8369</td><td>0.8250</td><td>0.7574</td><td>0.7911</td><td>0.7739</td></tr><tr><td>20190313</td><td>a592ca6</td><td>soft_max</td><td><strong>0.8641</strong></td><td>0.8568</td><td>0.7930</td><td>0.8000</td><td>0.7965</td></tr><tr><td>20190313</td><td>257fbab</td><td>soft_max</td><td>0.8520</td><td>0.8474</td><td>0.7368</td><td>0.8252</td><td>0.7785</td></tr><tr><td>20190313</td><td>25b5456</td><td>soft_max</td><td>-</td><td><strong>0.8658</strong></td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="主要实验过程"><a href="#主要实验过程" class="headerlink" title="主要实验过程"></a>主要实验过程</h2><h3 id="公共模块定义"><a href="#公共模块定义" class="headerlink" title="公共模块定义"></a>公共模块定义</h3><p>构建公共处理模块有两个目的，一是方便复用，比方说文件的保存与加载、日志的定义；二是跟实验无关的一些中间处理过程。具体代码间GitHub，主要有：</p><p><code>config.py</code> 定义基本配置信息，超参数设置，方便做对比实验；</p><p><code>logger.py</code> 日志配置，实验过程保存至日志文件；</p><p><code>comm.py</code> 数据的加载与保存等公共方法；</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h3 id="评价方法"><a href="#评价方法" class="headerlink" title="评价方法"></a>评价方法</h3><p>评价方法是评价一个模型好坏的准则，本次比赛测评算法指定为AUC(Area Under the Curve)，AUC值越高可以任务情感分类结果越准确。扩展资料：<a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve">AUC-维基百科</a> | <a href="https://baike.baidu.com/item/AUC/19282953?fr=aladdin">AUC-百度百科</a></p><p>scikit-learn 已经有AUC的封装：<code>auc = roc_auc_score(y, y_score, average=&quot;macro&quot;)</code></p><p>新建 <code>report.py</code> 模块，定义Report类如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class Report():</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    对预测结果进行评估</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name=&#x27;&#x27;):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        初始化</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.f1 = []</span><br><span class="line">        self.p1 = []</span><br><span class="line">        self.r1 = []</span><br><span class="line"></span><br><span class="line">        self.f0 = []</span><br><span class="line">        self.p0 = []</span><br><span class="line">        self.r0 = []</span><br><span class="line">        self.auc_scores = []</span><br><span class="line">        self.auc = 0</span><br><span class="line"></span><br><span class="line">    def report_one_folder_by_lable(self, y, y_hat):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        中间结果</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        f1_1 = metrics.f1_score(y, y_hat, pos_label=1)</span><br><span class="line">        p_1 = metrics.precision_score(y, y_hat, pos_label=1)</span><br><span class="line">        r_1 = metrics.recall_score(y, y_hat, pos_label=1)</span><br><span class="line"></span><br><span class="line">        f1_0 = metrics.f1_score(y, y_hat, pos_label=0)</span><br><span class="line">        p_0 = metrics.precision_score(y, y_hat, pos_label=0)</span><br><span class="line">        r_0 = metrics.recall_score(y, y_hat, pos_label=0)</span><br><span class="line"></span><br><span class="line">        self.f1.append(f1_1)</span><br><span class="line">        self.p1.append(p_1)</span><br><span class="line">        self.r1.append(r_1)</span><br><span class="line"></span><br><span class="line">        self.f0.append(f1_0)</span><br><span class="line">        self.p0.append(p_0)</span><br><span class="line">        self.r0.append(r_0)</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;0 result p: &#123;:.4f&#125; r: &#123;:.4f&#125; f &#123;:.4f&#125;&quot;.format(p_0, r_0, f1_0))</span><br><span class="line">        logger.info(&quot;1 result p: &#123;:.4f&#125; r: &#123;:.4f&#125; f &#123;:.4f&#125;&quot;.format(p_1, r_1, f1_1))</span><br><span class="line">        return p_1</span><br><span class="line"></span><br><span class="line">    def report_one_folder(self, y, predict_proba, threshold=0.5):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        中间结果</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        logger.info(self.name)</span><br><span class="line">        y_hat = [1 if score[1] &gt;= threshold else 0 for score in predict_proba]</span><br><span class="line">        p_1 = self.report_one_folder_by_lable(y, y_hat)</span><br><span class="line"></span><br><span class="line">        # auc evaluate</span><br><span class="line">        y_score = predict_proba[:, 1]</span><br><span class="line">        auc = roc_auc_score(y, y_score, average=&quot;macro&quot;)</span><br><span class="line">        self.auc_scores.append(auc)</span><br><span class="line">        logger.info(&quot;AUC score: &#123;:.4f&#125;&quot;.format(auc))</span><br><span class="line"></span><br><span class="line">        self.auc = np.mean(self.auc_scores)</span><br><span class="line">        return auc</span><br><span class="line"></span><br><span class="line">    def report_final_result(self):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        最终结果</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        logger.info(self.name)</span><br><span class="line">        logger.info(</span><br><span class="line">            &quot;0 avg result p: &#123;:.4f&#125; r: &#123;:.4f&#125; f &#123;:.4f&#125;&quot;.format(np.mean(self.p0), np.mean(self.r0), np.mean(self.f0)))</span><br><span class="line">        logger.info(</span><br><span class="line">            &quot;1 avg result p: &#123;:.4f&#125; r: &#123;:.4f&#125; f &#123;:.4f&#125;&quot;.format(np.mean(self.p1), np.mean(self.r1), np.mean(self.f1)))</span><br><span class="line"></span><br><span class="line">        if len(self.auc_scores) &gt; 0:</span><br><span class="line">            ave_auc = np.mean(self.auc_scores)</span><br><span class="line">            logger.info(</span><br><span class="line">                &quot;AUC avg score: &#123;:.4f&#125;&quot;.format(ave_auc))</span><br><span class="line">            return ave_auc</span><br><span class="line">        return np.mean(self.p1)</span><br></pre></td></tr></table></figure><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>新建专门的特征提取模块，命名为：<code>feature.py</code>,代码及解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">from sklearn.feature_extraction.text import TfidfVectorizer</span><br><span class="line"></span><br><span class="line">import config</span><br><span class="line">import word_vec</span><br><span class="line">from logger import logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TFIDF():</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    提取文本的TFIDF特征</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self, data, min_df=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        初始化并拟合数据集</span><br><span class="line">        :param data:训练集文本</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self.data = data</span><br><span class="line">        logger.info(&#x27;init TfidfVectorizer&#x27;)</span><br><span class="line">        self.tfidf = TfidfVectorizer(min_df=min_df)</span><br><span class="line">        logger.info(&#x27;fitting Tfidf...&#x27;)</span><br><span class="line">        self.train_vec = self.tfidf.fit_transform(data).toarray()</span><br><span class="line">        logger.info(&#x27;end&#x27;)</span><br><span class="line"></span><br><span class="line">    def transform(self, data):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        拟合新的数据集</span><br><span class="line">        :param data: 测试集文本</span><br><span class="line">        :return:</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        return self.tfidf.transform(data).toarray()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Feature():</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    特征提取的封装类</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        import comm</span><br><span class="line">        # 加载训练集和测试集数据</span><br><span class="line">        self.train_data = comm.load_df(config.train_data_path)</span><br><span class="line">        self.test_data = comm.load_df(config.test_data_path)</span><br><span class="line">        self.test_ids = self.test_data[&quot;ID&quot;]  # 测试集中所有的id</span><br><span class="line">        self.y = self.get_target()  # 训练集中的情感标签</span><br><span class="line"></span><br><span class="line">        self.train_features = []</span><br><span class="line">        self.test_features = []</span><br><span class="line"></span><br><span class="line">        # 提取TFIDF特征</span><br><span class="line">        train_vec, test_vec = self.tfidf_vec()</span><br><span class="line">        self.train_features.append(pd.DataFrame(train_vec))</span><br><span class="line">        self.test_features.append(pd.DataFrame(test_vec))</span><br><span class="line"></span><br><span class="line">        # train_word_vec, test_word_vec = self.word_vec()  # 加了会很低</span><br><span class="line">        # self.train_features.append(pd.DataFrame(train_word_vec))</span><br><span class="line">        # self.test_features.append(pd.DataFrame(test_word_vec))</span><br><span class="line"></span><br><span class="line">        self.X = pd.concat(self.train_features, axis=1)</span><br><span class="line">        self.test_X = pd.concat(self.test_features, axis=1)</span><br><span class="line">        logger.info(&quot;Shape of train X: &#123;&#125;&quot;.format(self.X.shape))</span><br><span class="line">        logger.info(&quot;Shape of test X: &#123;&#125;&quot;.format(self.test_X.shape))</span><br><span class="line">        logger.info(&quot;Shape of y: &#123;&#125;&quot;.format(self.y.shape))</span><br><span class="line"></span><br><span class="line">    def get_target(self):</span><br><span class="line">        def get_lable(label):</span><br><span class="line">            if label == &#x27;Positive&#x27;:</span><br><span class="line">                return 1  # Positive 用1表示</span><br><span class="line">            else:</span><br><span class="line">                return 0</span><br><span class="line"></span><br><span class="line">        # 将训练集中的标签用 0 1表示</span><br><span class="line">        self.train_data[&#x27;y&#x27;] = self.train_data.apply(lambda x: get_lable(x[&#x27;label&#x27;]), axis=1)</span><br><span class="line">        return self.train_data[&#x27;y&#x27;].values.astype(&#x27;int&#x27;)</span><br><span class="line"></span><br><span class="line">    def tfidf_vec(self):</span><br><span class="line">        logger.info(&quot;start collect tfidf vec.&quot;)</span><br><span class="line">        # 用训练集初始化TFIDF</span><br><span class="line">        tfidf = TFIDF(self.train_data[&#x27;review&#x27;], min_df=config.tfidf_min_df)</span><br><span class="line">        train_vec = tfidf.train_vec</span><br><span class="line">        # 提取测试集的TFIDF特征</span><br><span class="line">        test_vec = tfidf.transform(self.test_data[&#x27;review&#x27;])</span><br><span class="line">        logger.info(&quot;shape of trian tfidf: &#123;&#125;&quot;.format(train_vec.shape))</span><br><span class="line">        logger.info(&quot;shape of test tfidf: &#123;&#125;&quot;.format(test_vec.shape))</span><br><span class="line">        return train_vec, test_vec</span><br><span class="line"></span><br><span class="line">    def word_vec(self):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        提取文本中的词向量表示</span><br><span class="line">        :return: 训练集词向量，测试集词向量</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        logger.info(&quot;word vec&quot;)</span><br><span class="line">        train_word_vec = word_vec.get_word_vec(self.train_data[&#x27;review&#x27;])</span><br><span class="line">        test_word_vec = word_vec.get_word_vec(self.test_data[&#x27;review&#x27;])</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;shape of trian word_vec: &#123;&#125;&quot;.format(train_word_vec.shape))</span><br><span class="line">        logger.info(&quot;shape of test word_vec: &#123;&#125;&quot;.format(test_word_vec.shape))</span><br><span class="line">        self.voc = word_vec.voc</span><br><span class="line">        return train_word_vec, test_word_vec</span><br></pre></td></tr></table></figure><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>新建训练模块，命名为：<code>train.py</code>,代码及解释如下：</p><h4 id="分类器的定义"><a href="#分类器的定义" class="headerlink" title="分类器的定义"></a>分类器的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">classfiers = &#123;&#125;</span><br><span class="line">features_name = []</span><br><span class="line"></span><br><span class="line">C = 1.0</span><br><span class="line"></span><br><span class="line"># classfiers[&#x27;xgb-5&#x27;]  = xgb_5</span><br><span class="line">svm_1 = svm.SVC(C=1.0, kernel=&#x27;rbf&#x27;, gamma=&#x27;auto&#x27;, probability=True)</span><br><span class="line">rfc_1 = RandomForestClassifier(n_estimators=100, random_state=10)</span><br><span class="line">rfc_2 = RandomForestClassifier(n_estimators=200, random_state=10)</span><br><span class="line">rfc_3 = RandomForestClassifier(n_estimators=300, random_state=10)</span><br><span class="line">rfc_4 = RandomForestClassifier(n_estimators=200, max_depth=13, min_samples_split=80, min_samples_leaf=10,</span><br><span class="line">                               oob_score=True, random_state=10, max_features=&#x27;sqrt&#x27;)</span><br><span class="line">rfc_5 = RandomForestClassifier(random_state=30, n_estimators=30, max_depth=11, max_features=0.5,</span><br><span class="line">                               criterion=&#x27;entropy&#x27;, min_samples_split=140, min_samples_leaf=50)</span><br><span class="line"># Build a forest and compute the feature importances</span><br><span class="line">forest_1 = ExtraTreesClassifier(n_estimators=25, random_state=0)</span><br><span class="line">forest_2 = ExtraTreesClassifier(n_estimators=250, random_state=0)</span><br><span class="line">rng = np.random.RandomState(1)</span><br><span class="line">bdt = AdaBoostClassifier(DecisionTreeClassifier(max_depth=3),</span><br><span class="line">                         algorithm=&quot;SAMME&quot;,</span><br><span class="line">                         n_estimators=100)</span><br><span class="line"></span><br><span class="line"># Decision Tree</span><br><span class="line">tree_clf = tree.DecisionTreeClassifier()</span><br><span class="line"></span><br><span class="line"># Gradient Boosting Classifier</span><br><span class="line">grad_clf = GradientBoostingClassifier()</span><br><span class="line"></span><br><span class="line"># Random Forest Classifier</span><br><span class="line">rand_clf = RandomForestClassifier(n_estimators=18)</span><br><span class="line"></span><br><span class="line"># NeuralNet Classifier</span><br><span class="line">neural_clf = MLPClassifier(alpha=1)</span><br><span class="line"></span><br><span class="line"># Naives Bayes</span><br><span class="line">nav_clf = GaussianNB()</span><br><span class="line"></span><br><span class="line">voting_clf = VotingClassifier(</span><br><span class="line">    estimators=[(&#x27;gbc&#x27;, grad_clf), (&#x27;nav&#x27;, nav_clf), (&#x27;neural&#x27;, neural_clf)],</span><br><span class="line">    voting=&#x27;soft&#x27;</span><br><span class="line">)</span><br><span class="line">voting_rfc = VotingClassifier(</span><br><span class="line">    estimators=[(&#x27;rfc&#x27;, rfc_1), (&#x27;rfc_2&#x27;, rfc_2), (&#x27;rfc_3&#x27;, rfc_3)],</span><br><span class="line">    voting=&#x27;soft&#x27;)</span><br><span class="line">classfiers[&#x27;neural_clf&#x27;] = neural_clf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classfiers[&#x27;nav_clf&#x27;] = nav_clf</span><br><span class="line">classfiers[&#x27;grad_clf&#x27;] = grad_clf</span><br><span class="line">classfiers[&#x27;tree_clf&#x27;] = tree_clf</span><br><span class="line">classfiers[&#x27;forest-1&#x27;] = forest_1</span><br><span class="line">classfiers[&#x27;forest-2&#x27;] = forest_2</span><br><span class="line">classfiers[&#x27;voting_clf&#x27;] = voting_clf</span><br><span class="line">classfiers[&#x27;voting_rfc&#x27;] = voting_rfc</span><br></pre></td></tr></table></figure><h4 id="训练过程-1"><a href="#训练过程-1" class="headerlink" title="训练过程"></a>训练过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def cv(X, y, clf):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    交叉验证 Cross-validation</span><br><span class="line">    :param X: 训练集特征</span><br><span class="line">    :param y: 目标label</span><br><span class="line">    :param clf: 分类器</span><br><span class="line">    :return: 交叉验证过程中的最佳模型</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    model = None</span><br><span class="line">    max_p = 0  # 记录实验中最好的模型</span><br><span class="line">    reporter = Report(&#x27;train&#x27;)  # 定义评价器</span><br><span class="line">    for i in range(1, 10):  # 10</span><br><span class="line">        logger.info(&quot;Folder &#123;&#125;&quot;.format(i))</span><br><span class="line">        x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=21 + i)</span><br><span class="line">        if config.DEBUG:</span><br><span class="line">            logger.info(</span><br><span class="line">                &quot;Train x data: (&#123;&#125;, &#123;&#125;), Train y data: &#123;&#125;&quot;.format(len(x_train), len(x_train[0]), Counter(y_train)))</span><br><span class="line">            logger.info(&quot;Test x data: (&#123;&#125;, &#123;&#125;), Test y data: &#123;&#125;&quot;.format(len(x_test), len(x_test[0]), Counter(y_test)))</span><br><span class="line"></span><br><span class="line">        clf.fit(x_train, y_train)  # 训练过程</span><br><span class="line">        predict_proba = clf.predict_proba(x_test)  # 返回每个类别的概率值</span><br><span class="line"></span><br><span class="line">        # TODO 随机 看结果对比submission结果</span><br><span class="line">        p = reporter.report_one_folder(y_test, predict_proba, threshold=0.5)</span><br><span class="line">        if p &gt; max_p:</span><br><span class="line">            max_p = p</span><br><span class="line">            logger.info(&quot;Max result: &#123;:.4f&#125;&quot;.format(p))</span><br><span class="line">            model = clf</span><br><span class="line">    reporter.report_final_result()</span><br><span class="line">    return model, reporter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def train_cv(X, y):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    对classfiers中的每个分类器执行 CV过程</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    reporters = &#123;&#125;</span><br><span class="line">    for index, (name, clf) in enumerate(classfiers.items()):</span><br><span class="line">        logger.info(&#x27;&#123;&#125;: &#123;&#125;&#x27;.format(name, clf))</span><br><span class="line">        model, train_reporter = cv(X, y, clf)</span><br><span class="line">        model_path = config.model_path + &#x27;_&#x27; + name + &quot;_&#123;:.4f&#125;&quot;.format(train_reporter.auc)</span><br><span class="line"></span><br><span class="line">        comm.save_file(model, model_path)</span><br><span class="line">        reporters[name] = [train_reporter]</span><br><span class="line"></span><br><span class="line">    logger.info(&quot;Sum result:\n&quot;)</span><br><span class="line">    logger.info(&#x27;===========&#x27;)</span><br><span class="line">    for name, train_reporter in reporters.items():</span><br><span class="line">        logger.info(&#x27;-----&#x27;)</span><br><span class="line">        logger.info(&quot;clf: &#123;&#125;&quot;.format(name))</span><br><span class="line">        train_reporter[0].report_final_result()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    import comm</span><br><span class="line">    from feature import Feature</span><br><span class="line"></span><br><span class="line">    f = Feature()  # 特征工程</span><br><span class="line">    train_cv(f.X, f.y)  # 十折交叉过程</span><br></pre></td></tr></table></figure><h3 id="预测过程"><a href="#预测过程" class="headerlink" title="预测过程"></a>预测过程</h3><p>模型训练完成以后就可以使用训练好的模型预测测试文件中的情感分类，新建 <code>predict.py</code> ，代码和解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">import comm</span><br><span class="line">from feature import Feature</span><br><span class="line"></span><br><span class="line"># 使用的模型文件</span><br><span class="line">model_path = &quot;./submissions/model_neural_clf_0.8352&quot;</span><br><span class="line">reslut_path = model_path.replace(&#x27;model&#x27;, &#x27;reslut&#x27;).replace(&#x27;0.&#x27;, &#x27;&#x27;)</span><br><span class="line">reslut_path = reslut_path + &quot;.csv&quot;  # 结果保存路径</span><br><span class="line">model = comm.load_file(model_path)  # 加载模型</span><br><span class="line"></span><br><span class="line">feature = Feature()</span><br><span class="line">test_feature = feature.test_X  # 测试文件特征</span><br><span class="line">ids = feature.test_ids</span><br><span class="line"># 预测过程，结果为两个label的概率</span><br><span class="line">predict_proba = model.predict_proba(test_feature)</span><br><span class="line">proba = predict_proba[:, 1]  # 这里只取1的概率</span><br><span class="line"></span><br><span class="line">data = []  # 最终结果</span><br><span class="line">assert len(ids) == len(proba)</span><br><span class="line">for id, p in zip(ids, proba):</span><br><span class="line">    data.append([id, p])</span><br><span class="line">result = pd.DataFrame(data, columns=[&#x27;ID&#x27;, &quot;Pred&quot;])</span><br><span class="line">comm.dump_submission(result, path=reslut_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全部实验项目代码见 <a href="https://github.com/jianchengss/kesci-sentiment-classification.git">GitHub</a></p><blockquote><p>关键字：<code>kesci</code>,<code>competition</code>, <code>sentiment</code>,<code>PyTorch</code></p><p>原载地址：<a href="https://www.jiancheng.ai/2019/03/15/kesci-sentiment-classification/">https://www.jiancheng.ai/2019/03/15/kesci-sentiment-classification/</a></p><p>转载请注明出处！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> kesci </tag>
            
            <tag> competition </tag>
            
            <tag> sentiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能新书推荐——《PyTorch机器学习从入门到实战》</title>
      <link href="/2018/11/08/pytorch-in-action-book/"/>
      <url>/2018/11/08/pytorch-in-action-book/</url>
      
        <content type="html"><![CDATA[<h1 id="《PyTorch机器学习从入门到实战》"><a href="#《PyTorch机器学习从入门到实战》" class="headerlink" title="《PyTorch机器学习从入门到实战》"></a>《PyTorch机器学习从入门到实战》</h1><h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>近年来，基于深度学习的人工智能掀起了一股学习的热潮。本书是使用PyTorch深度学习框架的入门书籍。本书从深度学习原理入手，由浅入深，阐述深度学习中神经网络、深度神经网络、卷积神经网络、自编码器、循环神经网络等，同时穿插学习PyTorch框架的各个知识点和基于知识点的实例。最后，综合运用PyTorch和深度学习知识，来解决实践中的具体问题，比如图像识别、文本分类和命令词识别等。可以说，本书是深度学习和PyTorch的入门教程，同时也引领读者登堂入室，进入机会和挑战的人工智能领域。</p><p>本书针对的对象是机器学习和人工智能的爱好者和研究者，希望其能够有一定的机器学习和深度学习知识，有一定的Python编程基础。</p><p>购书链接：<a href="http://www.cmpbook.com/stackroom.php?id=44729">机械工业出版社</a> | <a href="https://www.amazon.cn/dp/B07JRBZJ9M/ref=sr_1_7?ie=UTF8&qid=1540979335&sr=8-7&keywords=PyTorch%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">亚马逊</a> | <a href="http://product.china-pub.com/8053408">china-pub</a> | <a href="http://search.dangdang.com/?key=PyTorch%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%D1%A7%CF%B0%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%C5%B5%EF%BF%BD%CA%B5%D5%BD&act=input">当当</a> | <a href="https://search.jd.com/Search?keyword=PyTorch%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98&enc=utf-8&wq=PyTorch%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98&pvid=0265a6a4990c4bc58fd670c8d5f63aac">京东</a></p><p>书籍代码地址：<a href="https://github.com/xiaobaoonline/pytorch-in-action">https://github.com/xiaobaoonline/pytorch-in-action</a></p><p><img src="/./pytorch-in-action-book/PyTorch-in-action.png" alt="《PyTorch机器学习从入门到实战》-立体封"></p><p><img src="/./pytorch-in-action-book/PyTorch-in-action-information.jpg" alt="《PyTorch机器学习从入门到实战》-详情"></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">第 1 章 深度学习介绍</span><br><span class="line">    1.1 人工智能、机器学习与深度学习</span><br><span class="line">    1.2 深度学习工具介绍</span><br><span class="line">    1.3 PyTorch 介绍</span><br><span class="line">    1.4 你能从本书中学到什么</span><br><span class="line">第 2 章 PyTorch 安装和快速上手</span><br><span class="line">    2.1 PyTorch 安装</span><br><span class="line">    2.2 Jupyter Notebook 使用</span><br><span class="line">    2.3 NumPy 基础知识</span><br><span class="line">    2.4 PyTorch 基础知识</span><br><span class="line">第 3 章 神经网络</span><br><span class="line">    3.1 神经元与神经网络</span><br><span class="line">    3.2 激活函数</span><br><span class="line">    3.3 前向算法</span><br><span class="line">    3.4 损失函数</span><br><span class="line">    3.5 反向传播算法</span><br><span class="line">    3.6 数据的准备</span><br><span class="line">    3.7 PyTorch 实例：单层神经网络实现</span><br><span class="line">第 4 章 深度神经网络及训练</span><br><span class="line">    4.1 深度神经网络</span><br><span class="line">    4.2 梯度下降</span><br><span class="line">    4.3 优化器</span><br><span class="line">    4.4 正则化</span><br><span class="line">    4.5 PyTorch 实例：深度神经网络实现</span><br><span class="line">第 5 章 卷积神经网络</span><br><span class="line">    5.1 计算机视觉</span><br><span class="line">    5.2 卷积神经网络</span><br><span class="line">    5.3 MNIST 数据集上卷积神经网络的实现</span><br><span class="line">第 6 章 嵌入与表征学习</span><br><span class="line">    6.1 PCA</span><br><span class="line">    6.2 自编码器</span><br><span class="line">    6.3 词嵌入</span><br><span class="line">第 7 章 序列预测模型</span><br><span class="line">    7.1 序列数据处理</span><br><span class="line">    7.2 循环神经网络</span><br><span class="line">    7.3 LSTM 和 GRU</span><br><span class="line">    7.4 LSTM 在自然语言处理中的应用</span><br><span class="line">    7.5 序列到序列网络</span><br><span class="line">    7.6 PyTorch 实例：基于 GRU 和 Attention 的机器翻译</span><br><span class="line">第 8 章 PyTorch 项目实战</span><br><span class="line">    8.1 图像识别和迁移学习——猫狗大战</span><br><span class="line">    8.2 文本分类</span><br><span class="line">    8.3 语音识别系统介绍</span><br></pre></td></tr></table></figure><hr><blockquote><p>关键字：<code>人工智能</code>, <code>PyTorch</code></p><p>原载地址：<a href="https://blog.csdn.net/jianchengss/article/details/83744500">https://blog.csdn.net/jianchengss/article/details/83744500</a></p><p>转载请注明出处！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown中的变量引用</title>
      <link href="/2018/04/05/Markdown%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8/"/>
      <url>/2018/04/05/Markdown%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>写东西的时候突发奇想，Markdown支持变量引用吗？这么高大上的工具应该支持的吧？！于是就查阅了一些资料:果然支持！ 下面把变量引用的用法记录一下。<br>使用变量的好处，应该是很明显的：一处定义，处处使用，而且方便统一修改。</p><p>示例中二维码是我刚开通个人公众号，有兴趣的关注一波啊，应该是很安静的～ O(∩_∩)O</p><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>格式，支持中文 :-)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[baidu]:http://www.baidu.com</span><br><span class="line">[我的主页]:http://www.jiancheng.ai</span><br><span class="line">[image-qr-code]: https://gitee.com/jianchengss/resources/raw/master/images/weixin/mp_QR-code/Jason_pinyaxuan_8.jpg</span><br><span class="line">[image-error]: https://www.baidu.com/Jason_pinyaxuan_8.jpg</span><br></pre></td></tr></table></figure><p>定义的变量可以在文档的任何位置，而且在正文中不显示，比如说本文底部定义了上面代码块里的变量，供下面示例使用，不过页面上是看不到的。</p><p><font color=#ff0000 size=6 face="黑体">注意！</font>链接写的时候一定要带 <code>http://</code>,不然链接不生效，不要问我是怎么知道的！！</p><h2 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 示例1</span><br><span class="line">直接把key放入[],这样显示文本是key，链接为value</span><br><span class="line">（但是两个放在一行会出问题，而且要空一行才能正确显示两个。。。。）:</span><br><span class="line"></span><br><span class="line">[baidu]   [我的主页]  ← 这里有两，只会显示第一个，估计识别成两个中括号的模式了（因为鼠标放上去显示链接是第二个变量值，两个中括号中间空格无效）</span><br><span class="line"></span><br><span class="line">[baidu]</span><br><span class="line"></span><br><span class="line">[我的主页]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>直接把key放入[],这样显示文本是key，链接为value<br>（但是两个放在一行会出问题，而且要空一行才能正确显示两个。。。。）:</p><p><a href="http://www.baidu.com/">baidu</a>   <a href="http://www.jiancheng.ai/">我的主页</a>  ← 这里有两，只会显示第一个，估计识别成两个中括号的模式了（因为鼠标放上去显示链接是第二个变量值，两个中括号中间空格无效）</p><p><a href="http://www.baidu.com/">baidu</a></p><p><a href="http://www.jiancheng.ai/">我的主页</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### 示例2</span><br><span class="line">自定义链接显示文本 + key，分别在[]里：</span><br><span class="line"></span><br><span class="line">[百度][baidu] [我的主页][我的主页]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>自定义链接显示文本 + key，分别在[]里：</p><p><a href="http://www.baidu.com/">百度</a> <a href="http://www.jiancheng.ai/">我的主页</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### 示例3</span><br><span class="line">图片中引用变量：</span><br><span class="line"></span><br><span class="line">直接使用，前面加感叹号，这样图片失效的时候显示的是key，图片显示是value指向的图片：</span><br><span class="line"></span><br><span class="line">![image-qr-code]</span><br><span class="line">![image-error]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>图片中引用变量：</p><p>直接使用，前面加感叹号，这样图片失效的时候显示的是key，图片显示是value指向的图片：</p><p><img src="https://gitee.com/jianchengss/resources/raw/master/images/weixin/mp_QR-code/Jason_pinyaxuan_8.jpg" alt="image-qr-code"><br><img src="https://www.baidu.com/Jason_pinyaxuan_8.jpg" alt="image-error"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### 示例4</span><br><span class="line">感叹号+[图片失效是显示文本] + [key], 自定义图片失效是显文本:</span><br><span class="line"></span><br><span class="line">![图片失效是显示文本][image-qr-code]</span><br><span class="line"></span><br><span class="line">![图片加载失败][image-error]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><p>感叹号+[图片失效时显示文本] + [key], 自定义图片失效是显文本:</p><p><img src="https://gitee.com/jianchengss/resources/raw/master/images/weixin/mp_QR-code/Jason_pinyaxuan_8.jpg" alt="图片失效是显示文本"></p><p><img src="https://www.baidu.com/Jason_pinyaxuan_8.jpg" alt="图片加载失败"></p><blockquote><p>关键字：<code>Markdown</code>, <code>变量引用</code></p><p>原载地址：<a href="http://www.jiancheng.ai/2018/04/05/Markdown%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8/">http://www.jiancheng.ai/2018/04/05/Markdown中的变量引用/</a></p><p>转载请注明出处！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习资源汇总</title>
      <link href="/2018/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
      <url>/2018/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>:page.sourse<br>平时看到的机器学习相关资源汇总到这里，好记性不如烂笔头！</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650716071&idx=1&sn=7aa209732425c6a52536fbb9012a09fd&scene=4#wechat_redirect">学界 | 2010-2016年被引用次数最多的深度学习论文（附论文下载） </a></li><li><a href="http://www.jiqizhixin.com/article/1739">微软重磅论文提出LightRNN：高效利用内存和计算的循环神经网络</a></li><li><a href="https://github.com/mhagiwara/100-nlp-papers">100 Must-Read NLProc Papers</a></li><li><a href="https://github.com/songrotek/Deep-Learning-Papers-Reading-Roadmap">深度学习论文阅读路线图 Deep Learning Papers Reading Roadmap</a></li><li><a href="https://users.cs.duke.edu/~rongge/thesis.pdf">论文《Provable Algorithms for Machine Learning Problems》,机器学习若干问题的新颖，可证明，实用算法 “Provable Algorithms for Machine Learning Problems”, [Rong Ge, 2013] 涉及三大类：主题模型，稀疏、深度表示，隐变量模型、张量分解&#x2F;矩阵分解，PS: NIPS’16最佳学生论文合作者</a>(Provable Algorithms for Machine Learning Problems.pdf)</li><li><a href="https://openreview.net/pdf?id=rkdF0ZNKl">【论文】（论文+代码）加速的PixelCNN ++，图像生成效率提升了183倍</a>(FAST GENERATION FOR CONVOLUTIONAL AUTORGRESSIVE MODELS)</li><li><a href="https://mp.weixin.qq.com/s/2lU_PaTwStoDmXcD4KDe0g">机器学习和深度学习引用量最高的20篇论文（2014-2017） </a></li><li><a href="https://github.com/robi56/Deep-Learning-for-Recommendation-Systems">面向推荐系统的深度学习文献列表</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><a href="http://ml.memect.com/article/machine-learning-guide.html">机器学习入门资源不完全汇总</a></li><li><a href="https://www.analyticsvidhya.com/blog/2016/11/solution-for-skilltest-machine-learning-revealed/">机器学习水平自测40题(附答案&amp;解析) Solutions for Skilltest Machine Learning : Revealed</a></li></ul><h2 id="网站-amp-论坛"><a href="#网站-amp-论坛" class="headerlink" title="网站 &amp;论坛"></a>网站 &amp;论坛</h2><ul><li><a href="http://ml.memect.com/">机器学习日报</a></li><li><a href="http://lib.csdn.net/base/machinelearning">机器学习：CSDN知识库</a></li><li>博客：<a href="http://www.cnblogs.com/subconscious/">计算机的潜意识</a><ul><li><a href="http://www.cnblogs.com/subconscious/p/4107357.html">机器学习基本方法</a></li></ul></li><li><a href="http://blog.csdn.net/hopever/article/details/17451139">机器学习所需的数学基础</a></li><li><a href="https://yq.aliyun.com/articles/65145?spm=5176.100238.goodcont.32.5rndmQ">【技术干货】Docker精华学习资料集锦</a></li><li>西瓜书<ul><li><a href="http://blog.csdn.net/icefire_tyh/article/details/52064910">机器学习(周志华西瓜书) 参考答案 总目录 </a></li></ul></li><li><a href="https://github.com/exacity/deeplearningbook-chinese">深度学习中文版</a> 来自liip师兄的分享</li><li>神经网络演示  <a href="http://playground.tensorflow.org/">http://playground.tensorflow.org/</a></li><li><a href="https://zhuanlan.zhihu.com/intelligentunit?utm_medium=social">知乎专栏：智能单元 聚焦通用人工智能</a></li><li><a href="http://www.52nlp.cn/%e5%8f%8d%e5%90%91%e4%bc%a0%e6%92%ad%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8%e8%b5%84%e6%ba%90%e7%b4%a2%e5%bc%95">反向传播算法入门资源索引</a></li><li><a href="https://zhuanlan.zhihu.com/p/26679704?utm_source=tuicool&utm_medium=referral">Java方向技术面试答案(汇总版)</a></li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li><a href="http://mp.weixin.qq.com/s/Qat8CWRQyii3OpbsPdliQg">Python 资源大全 </a></li><li><a href="https://juejin.im/entry/59a8c38c6fb9a0248926cc8e">用一个实际的数据集练手pandas</a></li><li><a href="https://www.kdnuggets.com/2016/04/top-10-ipython-nb-tutorials.html">Top 10 IPython Notebook </a></li><li><a href="http://www.techug.com/post/google-open-source-project-code-style-guide-python-code-guide.html">谷歌开源项目风格指南之 Python 风格指南</a></li><li><a href="http://www.dongwm.com/archives/wo-li-jie-de-pythonzui-jia-shi-jian/?comefrom=http://blogread.cn/news/">我理解的python最佳实践</a></li></ul><h2 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h2><ul><li><a href="https://towardsdatascience.com/transfer-learning-leveraging-insights-from-large-data-sets-d5435071ec5a">Applying transfer learning in NLP and CV</a></li><li><a href="https://towardsdatascience.com/applying-transfer-learning-in-nlp-and-cv-d4aaddd7ca90">https://towardsdatascience.com/applying-transfer-learning-in-nlp-and-cv-d4aaddd7ca90</a></li></ul><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ul><li><a href="https://github.com/BafS/Java8-CheatSheet">Java8-CheatSheet</a></li><li><a href="http://javarevisited.blogspot.hk/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html">Java 8 Tutorials, Resources, Books and Examples to learn Lambdas, Stream API and Functional Interfaces</a></li></ul><h2 id="博-文"><a href="#博-文" class="headerlink" title="博 文"></a>博 文</h2><ul><li><a href="http://www.cnblogs.com/mldllearningforbai/p/5316728.html">机器学习入门 ——奇迹不是因果的积累，而是宿命的选择</a></li><li>SVM <a href="http://blog.csdn.net/v_july_v/article/details/7624837">支持向量机通俗导论（理解SVM的三层境界）</a></li><li><a href="http://rodrigob.github.io/are_we_there_yet/build/classification_datasets_results.html">What is the class of this image 各种数据集上的数字识别汇总 </a></li><li><a href="https://www.zhihu.com/question/41231774">知乎：深度学习有哪些好玩的且易于实现的论文？ </a></li><li><a href="http://blog.csdn.net/lanxu_yy/article/details/29002543">文本挖掘预处理的流程总结 </a></li><li><a href="https://yq.aliyun.com/articles/66489?utm_campaign=wenzhang&utm_medium=article&utm_source=QQ-qun&utm_content=m_12260">这10本由浅入深的好书，或让你成为机器学习领域的专家</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=519056788&idx=1&sn=93acb101e28f201c71babb80cd58b060&chksm=00dce93f37ab6029097237d10f30c36096c164a0dc7ec7f3475bdeffb158e7fbc9e5bb79925e&mpshare=1&scene=1&srcid=0410Coc0ONBVqx756OQz7Zpb#rd">每天一个 Linux 命令：系列目录</a></li><li><a href="https://github.com/mezod/awesome-indie">独立开发者赚钱资料集锦</a></li><li><a href="http://blog.csdn.net/ifnoelse/article/category/1186188">各种相似度介绍</a>、</li><li><a href="http://blog.csdn.net/wds2006sdo?viewmode=contents">Python实现《统计学习方法》中的所有十个算法，</a></li><li><a href="https://yq.aliyun.com/articles/169880?spm=5176.100239.blogcont86580.25.q3FlxS">深度学习入门系列</a></li><li><a href="https://yq.aliyun.com/articles/406011?utm_content=m_41089">机器学习新手必学十大算法指南</a></li></ul><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><ul><li><p><a href="http://list.youku.com/albumlist/show?id=21508721&ascending=1&page=1">吴立德 《深度学习课程》</a></p></li><li><p>卷积神经网络：</p><ul><li><a href="http://cs231n.github.io/assets/conv-demo/index.html">卷积核可视化</a></li><li><a href="http://vision.stanford.edu/teaching/cs231n/">斯坦福大学的课程 :cs231n </a></li><li><a href="https://github.com/cs231n/cs231n.github.io">https://github.com/cs231n/cs231n.github.io</a></li><li><a href="http://cs231n.github.io/">http://cs231n.github.io/</a></li></ul></li><li><p><a href="https://zhuanlan.zhihu.com/p/24721292">CS 294：深度增强学习，2017年春季学期</a>  &amp;&amp; <a href="https://zhuanlan.zhihu.com/p/25298020">【Berkeley CS 294：深度增强学习，2017年春季学期】学习资源（附字幕）</a> 已转存</p></li><li><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLDS17.html">李宏毅</a>   <a href="http://forum.ai100.com.cn/blog/thread/ml-2017-04-09/#4094720592026380">台大李宏毅中文深度学习课程(2017)</a></p></li></ul><h2 id="本地资源"><a href="#本地资源" class="headerlink" title="本地资源"></a>本地资源</h2><h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><ul><li><a href="http://yann.lecun.com/exdb/mnist/">THE MNIST DATABASE</a></li><li>Face Recognition:The ORL dataset (Samaria F, Harter A (1994) Parameterisation of a stochastic model for human face identification, Proceedings of 2nd IEEE Workshop on Applications of Computer Vision.)</li><li>Music Classification:The GTZAN dataset: <a href="http://dspace.library.uvic.ca:8080/bitstream/handle/1828/1344/tsap02gtzan.pdf?sequence=1">Musical genre classification of audio signals</a></li><li>Hand Movement Recognition -The sEMG dataset <a href="https://www.researchgate.net/profile/Christos_Sapsanis/publication/257602303_Improving_EMG_based_classification_of_basic_hand_movements_using_EMD/links/56dfb7fd08ae979addef64a2.pdf">Improving EMG based classification<br>of basic hand movements using EMD</a></li><li><a href="http://archive.ics.uci.edu/ml/">UC Irvine Machine Learning Repository</a></li><li><a href="http://www.manythings.org/anki/?spm=5176.100239.blogcont221673.13.powgHo">双语平行语料：Tab-delimited Bilingual Sentence Pairs </a></li></ul><blockquote><p>关键字：<code>机器学习</code>, <code>资源列表</code></p><p>原载地址：<a href="http://www.jiancheng.ai/2018/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/">http://www.jiancheng.ai/2018/02/11/机器学习资源汇总/</a></p><p>转载请注明出处！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker:使用jupyter notebook基础镜像搭建自己的PyTorch开发环境</title>
      <link href="/2018/02/11/Docker-%E4%BD%BF%E7%94%A8jupyter-notebook%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84PyTorch%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/02/11/Docker-%E4%BD%BF%E7%94%A8jupyter-notebook%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84PyTorch%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>使用Docker搭建自己的PyTorch开发环境，方便迁移和远程使用。</p><h2 id="启动最基本的jupyter-notebook镜像："><a href="#启动最基本的jupyter-notebook镜像：" class="headerlink" title="启动最基本的jupyter notebook镜像："></a>启动最基本的jupyter notebook镜像：</h2><p>使用基础镜像<a href="https://hub.docker.com/r/jupyter/datascience-notebook/">jupyter&#x2F;datascience-notebook</a>,因为它预装了常用的模块：<code>pandas, matplotlib, scipy, seaborn, scikit-learn, scikit-image, sympy, cython, patsy, statsmodel, cloudpickle, dill, numba, bokeh</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -p 8888:8888 jupyter/datascience-notebook:281505737f8a</span><br></pre></td></tr></table></figure><p>其中<br><code>docker run </code>是使用一个镜像生成一个运行的容器；</p><p><code>-it</code>指交互模式，启动后终端在运行着的容器里面，与之对应的有<code>-d</code>后端运行模式，启动后终端交互在实体机，要想进入容器需要使用命令<code>docker exec -it container-name bash</code> <code>docker exec -it container-name</code>意为交互模式进入正在运行的一个容器，<code>bash</code>意为进入容器后使用的命令，这里用的是bash，这样进入容器后就能执行shell；</p><p><code>--rm</code>意为退出shell的时候自动删除容器，常在测试的时候使用，这样不用每次修改去删除已有的容器；</p><p><code>-p 8888:8888</code>指的是端口映射，前面的是实体机的端口，后面是容器里面暴露出的端口，两边端口可以不一样，这样同一个镜像可以启动多个对应不同端口的服务；</p><p><code>jupyter/datascience-notebook:281505737f8a</code>是镜像名字，冒号后面的是tag，类似于版本的概念，如果不显式的给出tag每次都回从hub上拉取latest的镜像，如果网络环境不好的话比较费时间，推荐显式给出tag，这样每次构建都会使用已有的镜像。</p><p>启动后就可以在终端看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[I 04:01:05.691 NotebookApp] Running the core application with no additional extensions or settings</span><br><span class="line">[I 04:01:05.692 NotebookApp] Serving notebooks from local directory: /home/jovyan</span><br><span class="line">[I 04:01:05.692 NotebookApp] 0 active kernels</span><br><span class="line">[I 04:01:05.692 NotebookApp] The Jupyter Notebook is running at:</span><br><span class="line">[I 04:01:05.692 NotebookApp] http://[all ip addresses on your system]:8888/?token=0a3331628e0e35f94eb0ad543faeb3e396fbccfa3ff06e5a</span><br><span class="line">[I 04:01:05.692 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span><br><span class="line">[C 04:01:05.692 NotebookApp] </span><br><span class="line">    </span><br><span class="line">    Copy/paste this URL into your browser when you connect for the first time,</span><br><span class="line">    to login with a token:</span><br><span class="line">        http://localhost:8888/?token=0a3331628e0e35f94eb0ad543faeb3e396fbccfa3ff06e5a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时是停在容器里面，打开浏览器 访问<code>http://localhost:8888/?token=0a3331628e0e35f94eb0ad543faeb3e396fbccfa3ff06e5a</code> 即可打开基本的jupyter notebook 环境，后面的token是随机生成的；</p><h2 id="启动带权限的容器"><a href="#启动带权限的容器" class="headerlink" title="启动带权限的容器"></a>启动带权限的容器</h2><h3 id="生成自定义token"><a href="#生成自定义token" class="headerlink" title="生成自定义token"></a>生成自定义token</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Python脚本生成密码</span><br><span class="line">import IPython</span><br><span class="line">IPython.lib.passwd()</span><br></pre></td></tr></table></figure><p>输入密码生成token  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test的token：sha1:6587feaef3b1:6b243404e4cfaafe611fdf494ee71fdaa8c4a563</span><br></pre></td></tr></table></figure><h3 id="自定义token运行容器："><a href="#自定义token运行容器：" class="headerlink" title="自定义token运行容器："></a>自定义token运行容器：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8888:8888 jupyter/datascience-notebook start-notebook.sh --NotebookApp.password=&#x27;sha1:6587feaef3b1:6b243404e4cfaafe611fdf494ee71fdaa8c4a563&#x27;</span><br></pre></td></tr></table></figure><p>这时访问<code>http://localhost:8888/</code>会出现输入密码的页面，输入正确的密码才能进入jupyter。</p><h2 id="共享目录"><a href="#共享目录" class="headerlink" title="共享目录"></a>共享目录</h2><h3 id="v参数"><a href="#v参数" class="headerlink" title="-v参数"></a>-v参数</h3><p>docker提供<code>-v</code>参数使实体机和容器共享目录，这对于有状态的服务很有用，目录挂载添加参数：<br><code>-v /home/jason/jason/docker/notebook:/home/jovyan/work</code></p><h3 id="运行带有目录共享的容器"><a href="#运行带有目录共享的容器" class="headerlink" title="运行带有目录共享的容器"></a>运行带有目录共享的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -p 8888:8888 -v /home/jason/jason/docker/notebook:/home/jovyan/work   jupyter/datascience-notebook start-notebook.sh --NotebookApp.password=&#x27;sha1:6587feaef3b1:6b243404e4cfaafe611fdf494ee71fdaa8c4a563&#x27;</span><br></pre></td></tr></table></figure><p>这样在jupyter里新建的notebook都会出现在实体机指定的目录里。由于这个镜像的原因 需在work目录下新建才能在实体机看到。</p><h2 id="基于jupyter-x2F-datascience-notebook-生成pytorch-image"><a href="#基于jupyter-x2F-datascience-notebook-生成pytorch-image" class="headerlink" title="基于jupyter&#x2F;datascience-notebook 生成pytorch image"></a>基于jupyter&#x2F;datascience-notebook 生成pytorch image</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>因为没有合适的pytorch镜像，自己编辑Dockerfile:</p><p>新建文件<code>Dockerfile</code>并编辑内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM jupyter/datascience-notebook:281505737f8a</span><br><span class="line">MAINTAINER Jason.W. &quot;jianchengss@163.com&quot;</span><br><span class="line"># 下面是按官网的方法安装spotlight</span><br><span class="line">#RUN pip --no-cache-dir install --upgrade install http://download.pytorch.org/whl/cu75/torch-0.2.0.post3-cp36-cp36m-manylinux1_x86_64.whl </span><br><span class="line">#RUN pip --no-cache-dir install --upgrade torchvision</span><br><span class="line"></span><br><span class="line"># pytorch</span><br><span class="line">RUN conda install pytorch torchvision -c soumith</span><br><span class="line"># spotlight(https://github.com/maciejkula/spotlight)</span><br><span class="line">RUN conda install -c maciejkula -c soumith spotlight=0.1.2</span><br></pre></td></tr></table></figure><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>在Dockerfile目录里运行命令：<code>docker build -t jianchengss/datascience-pytorch:0.1 .</code><br>这样就生成了image：<code>jianchengss/datascience-pytorch:0.1</code>可以运行<code>docker images</code>查看本机上所有的image。</p><h3 id="从构建的镜像运行容器"><a href="#从构建的镜像运行容器" class="headerlink" title="从构建的镜像运行容器"></a>从构建的镜像运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -p 8888:8888 -v ~/workspace/python/notebooks-pytorch:/home/jovyan/work  --privileged=true jianchengss/datascience-pytorch:0.1 start-notebook.sh --NotebookApp.password=&#x27;sha1:6587feaef3b1:6b243404e4cfaafe611fdf494ee71fdaa8c4a563&#x27;</span><br></pre></td></tr></table></figure><h3 id="最终容器"><a href="#最终容器" class="headerlink" title="最终容器"></a>最终容器</h3><p>经过以上步骤，测试完成后既可以执行最终运行的命令 注意 token换成自己的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8588:8888 -v ~/workspace/python/notebooks-pytorch:/home/jovyan/work  --privileged=true --name=pytorch jianchengss/datascience-pytorch:0.1 start-notebook.sh --NotebookApp.password=&#x27;sha1:7aee2f913c8e:17d40f203cbd5c9820f302894a92724c3de9fba6&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>-it --rm</code> 换成了 <code>-d</code>,比之前多的参数有：</p><p><code>--name=pytorch</code>，意为给container取一个名字，好区分和管理，缺省的话名字为一串随机的字符串。</p><p><code>--privileged=true</code>出现文件夹访问权限的时候添加该属性</p><p>此时运行<code>docker ps</code>即可查看运行着的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">3bd3e30e9ab3        jianchengss/datascience-pytorch:0.1   &quot;tini -- start-notebo&quot;   4 seconds ago       Up 3 seconds        0.0.0.0:8588-&gt;8888/tcp   pytorch</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进入容器操作"><a href="#进入容器操作" class="headerlink" title="进入容器操作"></a>进入容器操作</h3><p>容器启动后有时候需要进入容器操作，比方说查看信息或者安装新的软件，此时执行<code>docker exec -it pytorch bash </code></p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop container-name # 停止运行着的容器</span><br><span class="line">docker rm container-name # 删除已有的容器，要先停止</span><br><span class="line">docker rmi image-name # 删除已有的镜像</span><br></pre></td></tr></table></figure><blockquote><p>关键字：<code>docker</code> <code>jupyter notebook</code> <code>pytorch</code> <code>spotlight</code></p><p>原载地址：<a href="http://www.jiancheng.ai/2018/02/11/Docker-%E4%BD%BF%E7%94%A8jupyter-notebook%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84PyTorch%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">http://www.jiancheng.ai/2018/02/11/Docker-使用jupyter-notebook基础镜像搭建自己的PyTorch开发环境/</a></p><p>转载请注明出处！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
